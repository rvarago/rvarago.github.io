#+begin_export html
---
layout: post
title: C++ concepts for exact matching in overload resolution
permalink: /:title/
tags: [c++]
---
#+end_export

#+begin_quote
Resolving overload sets in C++ that differ in accepting ~bool~ vs ~std::string~ as parameters can cause surprises when we call them with string literals as arguments. We'll see how we can work around this with concepts.
#+end_quote
--------------

Consider this overload set, where the first accepts an ~std::string~ and the second accepts an ~bool~:
#+begin_src C++ :results output :exports both :includes <iostream> <string_view> :flags -std=c++20 :main no
void show(std::string_view s) {
  std::cout << "Showing the string: " << s << std::endl;
}

void show(bool b) {
  std::cout << "Showing the bool: " << b << std::endl;
}

int main() {
  show(true);
  show("A lovely string");
}
#+end_src

#+RESULTS:
: Showing the bool: 1
: Showing the string: A lovely string

The second call, namely ~show("A lovely string")~, selects the ~bool~ overload and therefore prints: ~Showing the bool: 1~.

However, it would be reasonable to have expected that the ~std::string_view~ overload would have been selected, and such surprises often become bugs.

Essentially, this happens due to a [[https://en.cppreference.com/w/cpp/language/implicit_conversion.html][conversion sequence]] from ~const char[16]~ (the type of ~"A lovely string"~) to ~bool~, and that's preferred over the alternative conversion to ~std::string_view~.

#+begin_center
The same holds if we replace ~std::string_view~ with ~const std::string&~.
#+end_center

There are different ways to "fix" this and each one depends on context, for instance:

- not overloading in the first place
- adding an overload that accepts a ~const char*~
- explicitly converting the literal into an ~std::string_view~ at call-site
- use a template with SFINAE

I'd like to show another option that improves upon "use a template with SFINAE" with C++20 concepts.

* Concepts for an exact match
Borrowing a little help from the standard ~std::same_as~ concept (and the [[https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/][constrained auto]] syntax for terseness), we can restrict the overload that accepts a ~bool~ to accept *exactly* a ~bool~ and thus "disallow" conversions:
#+begin_src C++ :results output :exports both :includes <iostream> <string_view> <concepts> :flags -std=c++20 :main no
void show(std::string_view s) {
  std::cout << "Showing the string: " << s << std::endl;
}

void show(std::same_as<bool> auto b) {
  std::cout << "Showing the bool: " << b << std::endl;
}

int main() {
  show(true);
  show("A lovely string");
}
#+end_src

#+RESULTS:
: Showing the bool: 1
: Showing the string: A lovely string

To be even more strict, we could change ~std::string_view~ to ~std::same_as<std::string_view>~ and thus *require* an explicit conversion:
#+begin_src C++ :results output :exports both :includes <iostream> <string_view> <concepts> :namespaces std::literals :flags -std=c++20 :main no
void show(std::same_as<std::string_view> auto s) {
  std::cout << "Showing the string: " << s << std::endl;
}

void show(std::same_as<bool> auto b) {
  std::cout << "Showing the bool: " << b << std::endl;
}

int main() {
  show(true);
  show("A lovely string"sv);
}
#+end_src

#+RESULTS:
: Showing the bool: 1
: Showing the string: A lovely string

Note that we had to explicitly convert the literal into an ~std::string_view~ -- in this case using the ~sv~ operator, but ~std::string_view{"A lovely string"}~ would work just as fine. Otherwise, a compilation error would occur.

And that's possibly safer.
